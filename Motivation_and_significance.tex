\section{Motivation and significance}
\subsection{Scientific background and the motivation for developing the software}

Conversion of the language of mathematics into the language of machine instructions, often defined as scientific and technical computing has been pioneered by the project FORTRAN \cite{Backus:1957:FAC}. Largely building upon the success of its predecessor, Matlab/Octave is a scientific and technical computing programming language widely used through academic community. Matlab has been introduced in late 1970s as an open source programming language for technical computing and later commercialized by Mathworks Inc. under MATLAB\textsuperscript{TM}. Being product of Mathworks Inc., MATLAB\textsuperscript{TM} became popular primary in education due simplified program syntax build on top of LAPACK (with its C and FORTRAN implementations). Later MATLAB gained among primarily engineers providing a flexible solutions for linear algebra, differential equations and a number of other problems engineers deal with on a daily basis \cite{moore2014matlab}. Introduced in the end of 1980s its syntaxial sibling, GNU Octave, offered an open source alternative to the commercial product of Mathworks \cite{eaton1997gnu}.

Yet more than a tool for engineers, in the last three decades Matlab/Octave has become a \textit{de facto} default tool for developing scientific code, often used to solve problems that are otherwise typical for general purpose programming languages. This, in turn, lead to an accumulation of prototype-like scientific software solutions unable to scale up to the promise and, thus, limiting the research work. To address this, in recent years a number of new programming languages and frameworks have been proposed including SciPy for Python \cite{jones2001open, Olivier_2002}, SCILAB \cite{Campbell_2009}, FreeMat, jLab, Rlab and others. While some projects managed to successfully undertake the effort of rewriting their research software into one of these new frameworks \cite{17076895, 21349861}, for many this represents a major problem due to programming language differences.

A newly introduced open source dynamic high level technical programing language Julia aims at shattering the paradigm that high level prototype code has to be inherently inefficient \cite{bezanson2012julia, bezanson2014julia}. Reported in \cite{bezanson2012julia} in 2012 Julia had attracted 550 mailing list subscribers, 1500 GitHub followers, 190 forks, and more than 50 total contributors. \href{https://github.com/JuliaLang/julia}{To date} the number of followers increased to 6251, forks to 1396 and contributors to 428. Apart from the very rich basic package Julia has currently 770 packages registered providing plentiful functionality enhancement. These packages span functionalities from audio signal processes, through CUDA interface, to Bioinformatic sequencing. Despite the young age Julia has been featured in several research papers in fields ranging from Computer Science and Technical Computing \cite{Heitzinger_2014, Knopp_2014, Foulds_2013} to Biochemistry \cite{Baldassi_2014}.

Unlike other high level technical computing languages Julia offers symbolic meta-programming (similar to LISP or Haskell), rich datatype system with templates support, multiple dispatch of methods allowing reusing them dynamically, and other attractive features of a modern programming language. The source code written in Julia is executed using just-in-time (JIT) compilation based on low level virtual machine (LLVM) \cite{Lattner_2004} bytecode may deliver performance matching performance of the iconic C language \cite{bezanson2012julia, bezanson2014julia}. As a consequence it allows direct invocation of C and FORTRAN routines (e.g. through the "ccall" keyword). Bezanson and colleagues suggest that in the modern dynamic technical computing languages there is pressure to write “vectorized” code to increase performance, which is unnatural for many problems and might generate large temporary objects and is therefore avoided by explicit loops in Julia approach \cite{bezanson2012julia}. In other words the authors claim that this pressure to vectorize the code is eliminated in Julia without compromising the performance. They imply that main features of Julia allowing performance increase despite using loops are rich type information, provided naturally by multiple dispatch, aggressive code specialization against run-time types, JIT compilation using the LLVM compiler framework \cite{bezanson2012julia, Lattner_2004}. In fact, for computation of the primitive Fibonacci recursion \href{http://julialang.org/benchmarks/}{authors claimed} Julia to be 1989.78 times faster than MATLAB\textsuperscript{TM} R2014a. Much like MATLAB/Octave, types in Julia are run time inferred, the algorithm used for such dynamic type inference and implementation details are described in \cite{Kaplan_1980, bezanson2012julia}. As Bezanson and colleagues mention, types may be used to make declarations, but their declaration is not required for performance \cite{bezanson2012julia}. This is achieved in several dynamic optimization passes addressing the method input/output typing and targeted LLVM code generation. The letter includes standard scalar optimizations, such as strength reduction, dead code elimination, jump threading, and constant folding (see \cite{bezanson2012julia} for the details). Taken together, these points may provide an incentive for the developers to switch from MATLAB/Octave to Julia. Similar to \textit{Esperanto} of human languages, the syntax of Julia combines to a larger extent syntaxes of Matlab/Octave, Python, R, Perl and many more languages. However as close as it may seem to Matlab/Octave the code written in Matlab/Octave requires significant modifications to be understood by Julia.

\subsection{Software importance for solving scientific problems}

Technical and scientific computing serves as the most fundamental scientific tool for tasks ranging from quantification of experimental results, to simulation of scientific hypotheses and making predictions for scientific fields ranging from Biology to Particle Physics. A large fraction of scientific questions in these fields are addressed using Matlab/Octave language.

Here we present \href{https://github.com/MatlabCompat/MatlabCompat.jl}{MatlabCompat.jl} a Julia language library aimed at simplifying the conversion of Matlab/Octave based research software to the novel Julia technical computing language by providing one-way compatibility and Matlab/Octave to Julia code translating modules. Conversion of Matlab/Octave to Julia may broaden research software usability by introduction of Julia supported best features from languages like R, Perl and Python, improve performance (especially of the code using loops), facilitate code exchange by offering IJulia notebooks (see IJulia package) and enforcing \href{http://github.com}{Github} social coding  and reproducibility of scientific results. The latter may, in turn, prolong the lifetime of research software tools by simplifying maintenance, accessibility and publishing of the scientific code. The library is written in native Julia alone, available on Github under MIT open source license and is a part of official Julia package repository.

A very specific example of scientific question to be addressed is automated quantification of micrographs of cultured cells obtained in phenotypical high-throughput screening (HTS). Due to a very large number of images generated (terabytes to petabytes \cite{R_m__2014}), it is impossible to perform such quantifications manually. Therefore quantification of HTS images is typically addressed using among others Matlab/Octave \cite{22787215, 17076895, R_m__2014}. Using \href{https://github.com/MatlabCompat/MatlabCompat.jl}{MatlabCompat.jl} this scientific question can now be addressed potentially more efficiently with Julia.

\subsection{Contribution to the process of scientific discovery}

Matlab/Octave is widely used to develop complex research software, e.g. in the filed of image analysis \cite{Kiss_2014, 17076895}. Beyond image analysis \href{https://github.com/MatlabCompat/MatlabCompat.jl}{MatlabCompat.jl} spans already at its early stage of development a handful of functions including input/output, working with strings, linear algebra and others providing researchers with an easy-to-reach Matlab/Octave runtime alternative. \href{https://github.com/MatlabCompat/MatlabCompat.jl}{MatlabCompat.jl} allows researchers to first easily convert their Matlab/Octave code into Julia and then enrich their code using Julia language. The added values of such code conversion efforts include using features like dynamic types, dataframes, as well as, allowing for performance gain. To illustrate how \href{https://github.com/MatlabCompat/MatlabCompat.jl}{MatlabCompat.jl} helps solving typical scientific problem of experimental results quantification, below we provide a typical use case from image analysis of micrographs obtained with an automated epifluorescent screening microscope (based on published data \cite{22787215}).

\subsection{Experimental setting}

The range of the settings where \href{https://github.com/MatlabCompat/MatlabCompat.jl}{MatlabCompat.jl} can be used is as broad as scientific and technical computing themselves. It ranges from data acquisition, mining and analysis to modeling, simulation and prediction. It aims at providing added value to existing Matlab/Octave solutions by assisting in code conversion into Julia - a language with broader possibilities and prospective performance optimization.

To use \href{https://github.com/MatlabCompat/MatlabCompat.jl}{MatlabCompat.jl} upon \href{http://julialang.org/downloads/}{download} and \href{http://docs.julialang.org/en/release-0.3/manual/getting-started/}{installation} of Julia distributive for the respective platform (or by simply using the \href{https://www.juliabox.org/}{JuliaBox} cloud service making any Julia code portable to other platforms including mobile), the user has to add the package by invoking:\\

\verb|Pkg.add("MatlabCompat")|\\

and subsequently before calling specific functions from our package:\\

\verb|using MatlabCompat|\\

Initial parsing of Matlab/Octave code and its pre-conversion to Julia code is provided by the function \textit{rosetta()} using following syntax:\\

\verb|rosetta(path/to/your/Mfile.m, path/to/new/jlfile.jl)|\\

\subsection{Related work}

One or two-way compatibility between different programming languages can be achieved either by manual or automatic translation, application program interface (API) based integration or, in cases of exceptional syntax similarity, by compatibility libraries. Multiple efforts on automatic translation of programming languages date to as early as 1960s \cite{Ledley_1962, irons1961syntax}. API based integrations exists between and for multiple programming languages and platforms, including e.g. Python \cite{autin2012upy}, MATLAB \cite{Bornstein_2008}. Julia languages has multiple APIs based integrations working and in development, including MATLAB.jl allowing calling MATLAB\textsuperscript{TM} using MATLAB\textsuperscript{TM} engine from Julia environment. Finally, compatibility libraries a typically written in the destination language and are a very common way to translate not just code but also principles and practices well established in one language to another language, like e.g. Matlab plotting library for Python \cite{Hunter_2007, barrett2005matplotlib}. While calling Matlab/Octave code from Julia is made possible by the MATLAB.jl package, there was no tool thus far assisting in conversion of Matlab/Octave 
code to Julia language. Automated program translation for Matlab/Octave into other high level programming languages poses additional practical challenges. Namely the absence of the official parsing grammar, runtime-dependent grammar parsing (interpretation), absence of the strict datatyping and others.

As Moynihan and colleagues suggest in their work on Pascal-SC to Ada automatic translator a comprehensive high-level to high-level language translation is generally unrealistic, but should the effort be undertaken capabilities of such a converter must be chosen carefully by weighing implementation costs \cite{Moynihan_1991}. For this reason in the specific case of MATLAB/Octave to Julia translation we aim for a pragmatic one-way transliteration following 'transliterate and refine' strategy described in \cite{Waters_1988}. We argue that the latter makes sense in the specific case of MATLAB/Octave to Julia translation due to the likeness of the syntax. Nonetheless, the practical challenge of such a translator lays in ensuring compatibility across the toolboxes (more than 60 in case of MATLAB) code bases of MATLAB/Octave and Julia. To this end, the rapidly growing Julia community (discussed below and observable on \href{https://github.com/JuliaLang/METADATA.jl/graphs/commit-activity}{GitHub}) has or is actively implementing overlapping functionalities independently via more than 770 Julia libraries (e.g. \href{https://github.com/timholy/Images.jl}{Images.jl} etc.). Syntax wrapping hence can be an easy way to achieve toolbox compatibility (in this paper illustrated e.g. by functions compatible with "Image Processing Toolbox" by Mathworks Inc.). Taken together, we argue that this means that the compatibility across the entire code base in the particular case of MATLAB/Octave to Julia translation may realistically be achieved as a community effort.

Here we propose to address the MATLAB/Octave to Julia compatibility using \href{https://github.com/MatlabCompat/MatlabCompat.jl}{MatlabCompat.jl} library package. We call for collaborative assistance on growing the functionality of the package, which can be accomplished by forking our source code through Github and pull-requesting your improvements later on (see details on contributing below). Additionally, \href{http://matlabcompat.github.io/}{MatlabCompat.jl} is set up as an \href{https://github.com/MatlabCompat}{organization on Github} aimed at uniting multiple researcher working on the package and creating a developers community.
  
  
  
  
  